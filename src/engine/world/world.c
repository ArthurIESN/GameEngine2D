#include <engine/world/world.h>

const int WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE = 8;

World* World_init()
{
    World* world = malloc(sizeof(World));
    world->staticObjects = malloc(sizeof(Object));
    //world->staticObjectsCount;
    world->dynamicObjects = malloc(sizeof(WorldDynamicObject));
   // world->dynamicObjectsCount;
    world->gravity = (Vector2){0, 0};
    world->worldSize = (Vector2){0, 0};
    world->isAutoGenerated = false;
    return world;
}


void World_AddStaticObject(World* world, Object* object)
{
    bool isMaxSizeReached = world->staticObjectsCount % WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE == 0;

    if(isMaxSizeReached)
    {
        DynamicArray_realloc((void **)&world->staticObjects, world->staticObjectsCount + WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE, sizeof(Object));
    }
    world->staticObjects[world->staticObjectsCount] = *object;
    world->staticObjectsCount++;
}

void World_RemoveStaticObject(World* world, int index)
{
    World_ShiftLeftStaticObject(world->staticObjects, index, world->staticObjectsCount);
    world->staticObjectsCount--;

    bool isMaxSizeReached = world->staticObjectsCount % WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE == 0;
    if(isMaxSizeReached)
    {
        DynamicArray_realloc((void **)&world->staticObjects, world->staticObjectsCount, sizeof(Object));
    }
}

void World_ShiftLeftStaticObject(Object* object, int indexStartShift, int arrayCount)
{
    // check if array is null
    if(object == NULL)
    {
        printf("DynamicArray : cannot shift elements to the left %s is NULL, memory will be free\n", GET_VARIABLE_NAME(object));
        free(object);
    } 
    else
    {
        // check if indexStartShift is out of bounds
        if(indexStartShift < 0 || indexStartShift > arrayCount)
        {
            printf("DynamicArray : cannot shift elements to the left %s is out of bounds, memory will be free\n", GET_VARIABLE_NAME(object));
            free(object);
        }
        else
        {
            // shift elements to the left
            for(int i = indexStartShift; i < arrayCount; i++)
            {
                object[i] = object[i + 1]; 
            }
        }
    }
}

void World_AddDynamicObject(World* world, WorldDynamicObject* object)
{
    bool isMaxSizeReached = world->dynamicObjectsCount % WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE == 0;

    if(isMaxSizeReached)
    {
        DynamicArray_realloc((void **)&world->dynamicObjects, world->dynamicObjectsCount + WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE, sizeof(WorldDynamicObject));
    }
    world->dynamicObjects[world->dynamicObjectsCount] = *object;
    world->dynamicObjectsCount++;
}

void World_RemoveDynamicObject(World* world, int index)
{
    World_ShiftLeftDynamicObject(world->dynamicObjects, index, world->dynamicObjectsCount);
    world->dynamicObjectsCount--;

    bool isMaxSizeReached = world->dynamicObjectsCount % WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE == 0;
    if(isMaxSizeReached)
    {
        DynamicArray_realloc((void **)&world->dynamicObjects, world->dynamicObjectsCount, sizeof(WorldDynamicObject));
    }
}

void World_ShiftLeftDynamicObject(WorldDynamicObject* object, int indexStartShift, int arrayCount)
{
    // check if array is null
    if(object == NULL)
    {
        printf("DynamicArray : cannot shift elements to the left %s is NULL, memory will be free\n", GET_VARIABLE_NAME(object));
        free(object);
    } 
    else
    {
        // check if indexStartShift is out of bounds
        if(indexStartShift < 0 || indexStartShift > arrayCount)
        {
            printf("DynamicArray : cannot shift elements to the left %s is out of bounds, memory will be free\n", GET_VARIABLE_NAME(object));
            free(object);
        }
        else
        {
            // shift elements to the left
            for(int i = indexStartShift; i < arrayCount; i++)
            {
                object[i] = object[i + 1]; 
            }
        }
    }
}