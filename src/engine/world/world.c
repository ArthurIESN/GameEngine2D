#include <engine/world/world.h>

const int WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE = 8;

World* World_init()
{
    World* world = malloc(sizeof(World));
    world->WorldObjects.staticObjects = malloc(sizeof(WorldStaticObject) * WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE);
    world->WorldObjects.staticObjectsCount = 0;
    world->WorldObjects.dynamicObjects = malloc(sizeof(WorldDynamicObject) * WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE);
    world->WorldObjects.dynamicObjectsCount = 0;
    world->gravity = (Vector2){0, 0};
    world->worldSize = (Vector2){0, 0};
    world->isAutoGenerated = false;
    return world;
}


void World_AddStaticObject(World* world, Object* object)
{
    bool isMaxSizeReached = world->WorldObjects.staticObjectsCount % WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE == 0;

    if(isMaxSizeReached)
    {
        DynamicArray_realloc((void **)&world->WorldObjects.staticObjects, world->WorldObjects.staticObjectsCount + WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE, sizeof(Object));
    }
    world->WorldObjects.staticObjects[world->WorldObjects.staticObjectsCount].object = object;
    world->WorldObjects.staticObjectsCount++;
}

void World_RemoveStaticObject(World* world, int index)
{
    World_ShiftLeftStaticObject(world->WorldObjects.staticObjects, index, world->WorldObjects.staticObjectsCount);
    world->WorldObjects.staticObjectsCount--;

    bool isMaxSizeReached = world->WorldObjects.staticObjectsCount% WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE == 0;
    if(isMaxSizeReached)
    {
        DynamicArray_realloc((void **)&world->WorldObjects.staticObjects, world->WorldObjects.staticObjectsCount, sizeof(Object));
    }
}

void World_ShiftLeftStaticObject(WorldStaticObject* objects, int indexStartShift, int arrayCount)
{
    // check if array is null
    if(objects == NULL)
    {
        printf("DynamicArray : cannot shift elements to the left %s is NULL, memory will be free\n", GET_VARIABLE_NAME(object));
        free(objects);
    } 
    else
    {
        // check if indexStartShift is out of bounds
        if(indexStartShift < 0 || indexStartShift > arrayCount)
        {
            printf("DynamicArray : cannot shift elements to the left %s is out of bounds, memory will be free\n", GET_VARIABLE_NAME(object));
            free(objects);
        }
        else
        {
            // shift elements to the left
            for(int i = indexStartShift; i < arrayCount; i++)
            {
                objects[i] = objects[i + 1]; 
            }
        }
    }
}

void World_AddDynamicObject(World* world, DynamicObject* object)
{
    bool isMaxSizeReached = world->WorldObjects.dynamicObjectsCount % WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE == 0;

    if(isMaxSizeReached)
    {
        DynamicArray_realloc((void **)&world->WorldObjects.dynamicObjects, world->WorldObjects.dynamicObjectsCount + WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE, sizeof(DynamicObject));
    }
    world->WorldObjects.dynamicObjects[world->WorldObjects.dynamicObjectsCount].dynamicObject = object;
    world->WorldObjects.dynamicObjectsCount++;
}

void World_RemoveDynamicObject(World* world, int index)
{
    World_ShiftLeftDynamicObject(world->WorldObjects.dynamicObjects, index, world->WorldObjects.dynamicObjectsCount);
    world->WorldObjects.dynamicObjectsCount--;

    bool isMaxSizeReached = world->WorldObjects.dynamicObjectsCount % WORLD_OBJECTS_DYNAMIC_ARRAY_CHUNK_SIZE == 0;
    if(isMaxSizeReached)
    {
        DynamicArray_realloc((void **)&world->WorldObjects.dynamicObjects, world->WorldObjects.dynamicObjectsCount, sizeof(DynamicObject));
    }
}

void World_ShiftLeftDynamicObject(WorldDynamicObject* objects, int indexStartShift, int arrayCount)
{
    // check if array is null
    if(objects == NULL)
    {
        printf("DynamicArray : cannot shift elements to the left %s is NULL, memory will be free\n", GET_VARIABLE_NAME(object));
        free(objects);
    } 
    else
    {
        // check if indexStartShift is out of bounds
        if(indexStartShift < 0 || indexStartShift > arrayCount)
        {
            printf("DynamicArray : cannot shift elements to the left %s is out of bounds, memory will be free\n", GET_VARIABLE_NAME(object));
            free(objects);
        }
        else
        {
            // shift elements to the left
            for(int i = indexStartShift; i < arrayCount; i++)
            {
                objects[i] = objects[i + 1]; 
            }
        }
    }
}